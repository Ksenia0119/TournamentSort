#pragma once

//@author Maltseva K.V.

#include <cassert>
using namespace std;
//печать массива
void printArr(int arr[], int arrLength)
{
    // Output the array
    for (int i = 0; i < arrLength; i++) {
        cout << arr[i] << " ";
    }
}
//турнирная сортировка
void tournamentSort(int arr[], int arrLength)
{
    // Определение размера турнирного дерева
    int treeSize = 1;
   /* цикл ищет наименьшее treeSize, которое будет достаточно большим, 
     чтобы вместить все элементы исходного массива в турнирном дереве.
        */
    while (treeSize <= arrLength) {
       // Турнирное дерево должно быть полным бинарным деревом, поэтому его размер должен быть степенью двойки.
        treeSize *= 2;
    }

    // Создание массива с размером, равным общему числу узлов (элементов) в турнирном дереве
    int size = (2 * treeSize);
    int* tree = new int[size];

    // Присвоение каждому узлу в дереве минимального значения для инт
    for (int i = 0; i < size; i++) {
        tree[i] = INT_MIN;
    }

    // Присвоение элементов из неотсортиванного массива в массив с общим числом узлов
    for (int i = 0; i < arrLength; i++) {

      /*  Расположение элементов в массиве tree начинается с позиции treeSize,
            так как первые treeSize узлов уже зарезервированы для присвоения 
            значений из исходного массива.*/
        tree[treeSize + i] = arr[i];
    }

    // Построение турнирного дерева путем выбора максимума каждой пары узлов

    /*начинаем с последнего уровня дерева и перемещаемся вверх по дереву, 
        выбирая максимальное значение из каждой пары узлов и присваивая 
        его родительскому узлу.*/
    for (int i = treeSize - 1; i >= 1; i--) {
       // Значение каждого узла на уровне i вычисляется как максимум из значений его двух дочерних узлов :
        tree[i] = max(tree[2 * i], tree[2 * i + 1]);
    }

    // Извлечение элементов из турнирного дерева в убывающем порядке
    int sortIndex = 0;
    while (sortIndex < arrLength) {

        // Присвоение корня исходному массиву и присвоение корню минимального значения
        arr[sortIndex++] = tree[1];
        tree[1] = INT_MIN;

        // Замена максимального значения на минимальное
        int node = 1;
        while (node < treeSize) {
            int leftChild = 2 * node;
            int rightChild = 2 * node + 1;

            // Узел получает индекс наибольшего значения
            node = (tree[leftChild] > tree[rightChild]) ? leftChild : rightChild;

            // Устанавливает наибольшее число в минимальное
            if (tree[leftChild] > tree[rightChild]) {
                tree[leftChild] = INT_MIN;
            }
            else {
                tree[rightChild] = INT_MIN;
            }
        }

        // выбор максимума каждой пары узлов
        for (int i = treeSize - 1; i >= 1; i--) {
            tree[i] = max(tree[2 * i], tree[2 * i + 1]);
        }
    }

    delete[] tree;
}
//
//INT_MIN часто используется для инициализации переменных или массивов в случаях,
//когда нужно обозначить неинициализированные значения или отсутствие данных.
//Например, в алгоритмах сортировки, таких как турнирная сортировка, 
//INT_MIN может использоваться для обозначения неинициализированных узлов 
//в турнирном дереве или для замены максимальных значений на минимальные.


void testTournamentSort()
{
    // Тестовый массив
    int arr[] = { 9, 2, 7, 1, 5 };
    /*       9
          / \
        2     7
       / \ 
      1   5*/
    int arrLength = sizeof(arr) / sizeof(arr[0]);

    // Вызов функции для сортировки массива
    tournamentSort(arr, arrLength);

    // Проверка, что массив отсортирован по убыванию
    for (int i = 0; i < arrLength - 1; i++) {
        assert(arr[i] >= arr[i + 1]);
    }

    int arr1[] = { 17 ,8,19,2,12,78,20,85 };
    int arrLength1 = sizeof(arr1) / sizeof(arr1[0]);


    // Вызов функции для сортировки массива
    tournamentSort(arr1, arrLength1);

    // Проверка, что массив отсортирован по убыванию
    for (int i = 0; i < arrLength1 - 1; i++) {
        assert(arr1[i] >= arr1[i + 1]);
    }


    cout << "Сортировка прошла тест";
}